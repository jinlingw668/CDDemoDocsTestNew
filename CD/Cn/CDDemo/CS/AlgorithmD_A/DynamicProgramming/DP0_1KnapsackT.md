---
layout: default
tags:
  - CD Demo
categories:
  - DynamicProgramming
permalink: CD/Cn/CDDemo/CS/AlgorithmD_A/DynamicProgramming/DP0_1KnapsackT
---
### <center>0-1 背包问题的动态规划算法描述</center>
<div align="right">
	<a href="{{'/CD/Cn/CDDemo/CS/QandA.html'| relative_url }}" target="_blank">Q&amp;A</a>
    &nbsp;&nbsp;
	<a href="{{'/CD/Cn/' | relative_url }}" target="_blank">Home</a>	
</div>
---

假定有n个物品，每件物品都有自身的重量和价值，第i件物品的重量和价值分别记为wi和vi（1\<=i\\=n）。另有一个容量为W的背包，并约定，任一组物品，只要重量总和不超过W就可以装入这个背包。背包问题，是从这组物品中选出最有价值的一个子集，并且可以装入背包中。如果限定物品不可分割，即一个物品要么装入，要么不装入，这样的背包问题，称为0-1背包问题（0-1 Knapsack problem）。为了简化问题形式，同时假设所有物品的重量wi和价值vi，以及背包容量W均为非负整数。

下面我们讨论如何使用动态规划方法解决0-1背包问题。

动态规划方法与分治法类似，也需要将原问题分解为子问题。在0-1背包问题中，对于W容量的背包和n个物品来讲，它的子问题可以是承重更少的背包，或者是更少的可选物品。

我们定义K[i, w]为背包容量为w时，从前i个物品中进行选择可获得的最优价值，并将所选择的物品子集称为最优子集。

假定已经解决了前i-1个物品装入背包容量为w的最优价值问题，即已知K[i-1, w]，我们看看是否对解决n个物品的装入问题K[i, w]有帮助。对于K[i, w]的最优子集来讲，第i个物品的装入情况只有两种可能，或者说只有两种可行方案。如果物品i选择不装入，那么最优价值就是前i-1个物品装入w容量背包的最优价值，即K[i, w] = K[i-1, w]；而如果物品i选择装入（当然，前提是可以装入，即 wi <= w），那么背包必须为物品i空出wi的空间，并且还需要针对前i-1件物品解决装入剩余背包容量为w-wi的最优价值问题，此时K[i, w] = vi + K[i-1, w-wi]。而K[i, w]的最优价值，需要比较这两种可行方案，选择其中可获取价值较大的一个。如此，i个物品的装包问题，转换成了两个更小的i-1个物品的装包子问题。

对前i-1个物品的装入问题可以使用相同的方法继续分解，当分解到只剩下(前)一个物品时，这个物品要么放到背包里，要么不放到背包里。
相应的，我们来看看K[1, w]的最优价值情况。当只有(第)一件物品（重量和价值分别为w1和v1，背包容量为w）可选时
如果物品1的重量不超过背包容量w，即 w1<=w，显然装入物品1可获得最优价值，K[1, w] = v1。
如果物品1的重量超出了背包容量w，即 w1 > w，那么物品装不下，最优价值只能是 K[1, w] = 0。

而 当i = 0或 w=0时
显然，K[i,0]=K[0,w]=0，因为当背包容量为0或物品数量为0时，装入背包物品的所有价值组合都是0，最优价值自然也是0。

从上面的分析中，不难推导出K[i, w]的递推式如下：
对于 i>0,w>0
    当 wi<=w时      K[i, w] = max{ K[i-1,w] ，K[i-1,w-wi]+vi}
    当 wi>w时        K[i, w] =  K[i-1,w] 
对于 i>0或w>0
     K[i,0] = K[0,w] = 0
	 

#### 算法思想
面对 n 件物品，每一次只对前 1,2,3,... 直到前 n 件物品考虑 ( 对应变量 i , 1≤i≤n )；
而每次考虑前 i 件物品时，均从背包容量为 1,2,3,... 直到 W 时一步步考虑 ( 对应变量 j , 1≤j≤W )。
由此定义一个二维数组 V(i,j) 表示当前背包容量为 j 时，前 i 个物品组合所取得的最大价值。

计算每一项 V(i,j) 时，即面对前 i 件物品、背包容量只有 j 时，有两种可能：

若背包的容量 j 比第 i 件物品重量 w(i) 小，装不下、不能装，此时的价值与前i-1个的价值相同，即 
		V(i, j)=V(i-1, j)；

若背包的容量 j 可以装第 i 件物品，但装入不一定能达到当前最优价值，需要在装与不装之间选择最优的一个，也就是物品组合总价值更大的那个，即
		V(i, j) = max｛ V(i-1, j)，V(i-1, j-w(i)) + v(i) ｝


- V(i-1,j) 表示不装第 i 个物品，此时价值与前i-1个的价值相同；

- V(i-1,j-w(i)) + v(i)  表示装入第 i 个物品（价值 v(i) ），那么当前背包容量 j 中必有 w(i) 个容量给了物品 i ，而剩余 j-w(i) 个容量用来装物品 i 外的其它所有物品（对应前 i-1 个物品集合，最优价值 V(i-1, j-w(i))）。

#### 算法核心

```
1. 初始时，物品 i 的重量和价值为 w[i-1], v[i-1]；置 V[0][ ]= 0，V[ ][0]= 0
2. 逐行推导
for ( i = 1 to n ) {  // 枚举物品
	for ( j = 1 to W ) {  // 枚举背包容量
		if ( j < w[i - 1] ) {  // 容量 小于 i 的重量，装不下
			V[i][j] = V[i-1][j] ;  } // 价值等于上一行，同一列
		else {  // 能装下，比较装入和不装入，取最优价值
			V[i][j] = max( V[i-1, j], V[i-1, j-w(i - 1)] + v[i - 1] ) ;  }}}
3. V[n][W] 即为物品最优组合价值。
```
为便于理解，推导过程采用逐行而非逐列方式。